# ğŸ’» Engenharia de Software

Projeto desenvolvido para a disciplina de **Engenharia de Software**, ministrada pelo professor **Bertoti**.

---

## ğŸ› ï¸ Ferramenta Utilizada
- **IntelliJ IDEA**
- **Ollama**
- **GitHub**



---

## ğŸ¯ Objetivo

Este repositÃ³rio tem como finalidade **armazenar e organizar os cÃ³digos e atividades** da disciplina, servindo como apoio para os estudos e o desenvolvimento prÃ¡tico dos conceitos aprendidos em sala de aula.

---

## ğŸ“– ComentÃ¡rios sobre o livro *Software Engineering at Google* (O'Reilly)

### ğŸ”¹ 1. Primeiro Trecho
O livro traz ensinamentos valiosos sobre as atribuiÃ§Ãµes de cada profissional da Ã¡rea de tecnologia.  
HÃ¡ diferenÃ§as claras entre cargos e responsabilidades:  
- O **engenheiro de software** lida com trabalhos mais complexos e de longo prazo.  
- O **cientista de dados** pode atuar como programador, criando soluÃ§Ãµes especÃ­ficas.  

A principal distinÃ§Ã£o estÃ¡ na **capacidade lÃ³gica e visÃ£o de futuro** do engenheiro de software, que precisa pensar em soluÃ§Ãµes estruturadas e tomar decisÃµes tÃ©cnicas mais rigorosas.

---

### ğŸ”¹ 2. Segundo Trecho
- Programar vai alÃ©m de apenas escrever cÃ³digo.  
- Ã‰ necessÃ¡rio pensar em **como o cÃ³digo vai evoluir ao longo do tempo**.  
- O desenvolvedor deve **acompanhar as mudanÃ§as da empresa**.  
- Ã‰ importante **reduzir riscos e custos futuros**.  
- O cÃ³digo possui um **ciclo de vida**, da criaÃ§Ã£o atÃ© a descontinuidade.  
- A engenharia de software envolve:
  - **Planejamento**  
  - **ManutenÃ§Ã£o**  
  - **Cuidado contÃ­nuo**

---
## 3 - âš–ï¸ Exemplos de Tradeoffs

# ğŸ• 1. Velocidade x Qualidade
1. Entrega apressada de um app mobile:
A equipe lanÃ§a o aplicativo antes do prazo para atender uma campanha de marketing, mas vÃ¡rios bugs aparecem logo apÃ³s o lanÃ§amento.

2. Sistema web sem testes automatizados:
Para economizar tempo, os desenvolvedores pulam os testes. O sistema funciona, mas falhas crÃ­ticas surgem nas atualizaÃ§Ãµes seguintes.

3. Site feito Ã s pressas para um cliente:
O site Ã© entregue no prazo, mas o cÃ³digo Ã© desorganizado, dificultando futuras alteraÃ§Ãµes e correÃ§Ãµes.

# âš™ï¸ 2. Simplicidade x Escalabilidade

1. Banco de dados Ãºnico para tudo:
Um sistema pequeno usa apenas um banco centralizado (ex: SQLite), mas quando o nÃºmero de usuÃ¡rios cresce, ele nÃ£o aguenta a demanda.

2. CÃ³digo â€œhardcodedâ€:
Valores fixos sÃ£o colocados diretamente no cÃ³digo (como URLs ou taxas). Isso simplifica o inÃ­cio, mas dificulta ajustes quando o sistema precisa se adaptar.

3. Arquitetura monolÃ­tica:
Criar tudo em um Ãºnico projeto Ã© mais simples no comeÃ§o, mas torna o sistema difÃ­cil de escalar ou dividir em microsserviÃ§os no futuro.

# ğŸ’° 3. Custo x ManutenÃ§Ã£o

1. Hospedagem barata:
A empresa escolhe um servidor de baixo custo, que cai com frequÃªncia. A equipe gasta mais tempo (e dinheiro) corrigindo falhas e migraÃ§Ãµes.

2. Desenvolvedores juniores sem supervisÃ£o:
A contrataÃ§Ã£o Ã© mais barata no inÃ­cio, mas o cÃ³digo mal estruturado exige reescrita completa meses depois.

3. Uso de tecnologias defasadas:
Optar por ferramentas antigas para economizar licenÃ§as leva a altos custos de manutenÃ§Ã£o e falta de compatibilidade no futuro.


## ğŸŒ Conceitos IntangÃ­veis

- O **front-end** Ã© apenas a ponta do iceberg.  
- HÃ¡ custos de operaÃ§Ã£o e sustentaÃ§Ã£o da plataforma.  
- Um sistema envolve **mÃºltiplos bancos de dados e linguagens**.  
- O verdadeiro valor estÃ¡ na **integraÃ§Ã£o de sistemas** e na **engenharia de dados**.

---

## ğŸ§© Diagrama UML de Relacionamento

### ğŸ“„ DescriÃ§Ã£o
O diagrama a seguir representa a relaÃ§Ã£o entre as classes **Fazenda**, **Humano** e **Ovelha**, conforme desenvolvido na atividade prÃ¡tica da disciplina.

<p align="center">
  <img src="https://github.com/ErickvFaria/bertoti/blob/main/UML_relacionamento.png?raw=true" alt="Diagrama UML de Relacionamento" width="600"/>
</p>

---

## ğŸ‘¨â€ğŸ“ Autor

**Erick VinÃ­cius de Faria**  
Curso: **Banco de Dados â€“ 2Âº Semestre**  
FATEC SÃ£o JosÃ© dos Campos
