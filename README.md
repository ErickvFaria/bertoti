# Engenharia de Software

Projeto desenvolvido para a disciplina de **Engenharia de Software**, ministrada pelo professor **Bertoti**.

## 🛠️ Ferramenta utilizada

* IntelliJ IDEA

## 📌 Objetivo

Este repositório tem como finalidade armazenar e organizar os códigos e atividades da disciplina, servindo como apoio para os estudos e desenvolvimento prático dos conceitos aprendidos em sala de aula.

---

## 📖 Comentários sobre o livro *Software Engineering at Google* (O'Reilly)

### 1 - 🔹 Primeiro trecho
De acordo com o livro, podemos tirar bons ensinamentos sobre as atribuições de cada profissional da área de tecnologia. Observa-se uma diferença de perspectivas entre cargos e responsabilidades:  
- O **engenheiro de software** tende a lidar com trabalhos mais demorados e complexos.  
- O **cientista de dados** pode atuar como programador, criando soluções específicas.  

O ponto de maior distinção está na capacidade lógica e visão de futuro do engenheiro de software, que precisa pensar em soluções mais estruturadas e tomar decisões mais rigorosas, características marcantes da engenharia.

### 2 - 🔹 Segundo trecho

Programar vai além de apenas escrever código.
É necessário pensar em como o código vai evoluir ao longo do tempo.
O desenvolvedor deve acompanhar as mudanças da empresa.
É importante reduzir riscos e custos futuros.
O código possui um ciclo de vida, que vai da criação à descontinuidade.
A engenharia de software envolve:
Planejamento,
Manutenção,
Cuidado contínuo.

---

## 3 - ⚖️ Exemplos de Tradeoffs

# 🕐 1. Velocidade x Qualidade
1. Entrega apressada de um app mobile:
A equipe lança o aplicativo antes do prazo para atender uma campanha de marketing, mas vários bugs aparecem logo após o lançamento.

2. Sistema web sem testes automatizados:
Para economizar tempo, os desenvolvedores pulam os testes. O sistema funciona, mas falhas críticas surgem nas atualizações seguintes.

3. Site feito às pressas para um cliente:
O site é entregue no prazo, mas o código é desorganizado, dificultando futuras alterações e correções.

# ⚙️ 2. Simplicidade x Escalabilidade

1. Banco de dados único para tudo:
Um sistema pequeno usa apenas um banco centralizado (ex: SQLite), mas quando o número de usuários cresce, ele não aguenta a demanda.

2. Código “hardcoded”:
Valores fixos são colocados diretamente no código (como URLs ou taxas). Isso simplifica o início, mas dificulta ajustes quando o sistema precisa se adaptar.

3. Arquitetura monolítica:
Criar tudo em um único projeto é mais simples no começo, mas torna o sistema difícil de escalar ou dividir em microsserviços no futuro.

# 💰 3. Custo x Manutenção

1. Hospedagem barata:
A empresa escolhe um servidor de baixo custo, que cai com frequência. A equipe gasta mais tempo (e dinheiro) corrigindo falhas e migrações.

2. Desenvolvedores juniores sem supervisão:
A contratação é mais barata no início, mas o código mal estruturado exige reescrita completa meses depois.

3. Uso de tecnologias defasadas:
Optar por ferramentas antigas para economizar licenças leva a altos custos de manutenção e falta de compatibilidade no futuro.

---

## - 🌐 Intangível

- O **front-end** é apenas a ponta do iceberg.  
- Há custos de operação e sustentação de plataforma.  
- Um sistema envolve múltiplos bancos de dados e linguagens.  
- O verdadeiro valor está na **integração de sistemas** e na **engenharia de dados**.

---

## 4 Classe UML upado nas documentações. ![Diagrama UML de relacionamento](https://github.com/ErickvFaria/bertoti/blob/main/UML_relacionamento.png)



👨‍🎓 Autor
Erick Vinícius de Faria

Curso: Banco de Dados – 2º semestre
