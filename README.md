# Engenharia de Software

Projeto desenvolvido para a disciplina de **Engenharia de Software**, ministrada pelo professor **Bertoti**.

## ğŸ› ï¸ Ferramenta utilizada

* IntelliJ IDEA

## ğŸ“Œ Objetivo

Este repositÃ³rio tem como finalidade armazenar e organizar os cÃ³digos e atividades da disciplina, servindo como apoio para os estudos e desenvolvimento prÃ¡tico dos conceitos aprendidos em sala de aula.

---

## ğŸ“– ComentÃ¡rios sobre o livro *Software Engineering at Google* (O'Reilly)

### 1 - ğŸ”¹ Primeiro trecho
De acordo com o livro, podemos tirar bons ensinamentos sobre as atribuiÃ§Ãµes de cada profissional da Ã¡rea de tecnologia. Observa-se uma diferenÃ§a de perspectivas entre cargos e responsabilidades:  
- O **engenheiro de software** tende a lidar com trabalhos mais demorados e complexos.  
- O **cientista de dados** pode atuar como programador, criando soluÃ§Ãµes especÃ­ficas.  

O ponto de maior distinÃ§Ã£o estÃ¡ na capacidade lÃ³gica e visÃ£o de futuro do engenheiro de software, que precisa pensar em soluÃ§Ãµes mais estruturadas e tomar decisÃµes mais rigorosas, caracterÃ­sticas marcantes da engenharia.

### 2 - ğŸ”¹ Segundo trecho

Programar vai alÃ©m de apenas escrever cÃ³digo.
Ã‰ necessÃ¡rio pensar em como o cÃ³digo vai evoluir ao longo do tempo.
O desenvolvedor deve acompanhar as mudanÃ§as da empresa.
Ã‰ importante reduzir riscos e custos futuros.
O cÃ³digo possui um ciclo de vida, que vai da criaÃ§Ã£o Ã  descontinuidade.
A engenharia de software envolve:
Planejamento,
ManutenÃ§Ã£o,
Cuidado contÃ­nuo.

---

## 3 - âš–ï¸ Exemplos de Tradeoffs

# ğŸ• 1. Velocidade x Qualidade
1. Entrega apressada de um app mobile:
A equipe lanÃ§a o aplicativo antes do prazo para atender uma campanha de marketing, mas vÃ¡rios bugs aparecem logo apÃ³s o lanÃ§amento.

2. Sistema web sem testes automatizados:
Para economizar tempo, os desenvolvedores pulam os testes. O sistema funciona, mas falhas crÃ­ticas surgem nas atualizaÃ§Ãµes seguintes.

3. Site feito Ã s pressas para um cliente:
O site Ã© entregue no prazo, mas o cÃ³digo Ã© desorganizado, dificultando futuras alteraÃ§Ãµes e correÃ§Ãµes.

# âš™ï¸ 2. Simplicidade x Escalabilidade

1. Banco de dados Ãºnico para tudo:
Um sistema pequeno usa apenas um banco centralizado (ex: SQLite), mas quando o nÃºmero de usuÃ¡rios cresce, ele nÃ£o aguenta a demanda.

2. CÃ³digo â€œhardcodedâ€:
Valores fixos sÃ£o colocados diretamente no cÃ³digo (como URLs ou taxas). Isso simplifica o inÃ­cio, mas dificulta ajustes quando o sistema precisa se adaptar.

3. Arquitetura monolÃ­tica:
Criar tudo em um Ãºnico projeto Ã© mais simples no comeÃ§o, mas torna o sistema difÃ­cil de escalar ou dividir em microsserviÃ§os no futuro.

# ğŸ’° 3. Custo x ManutenÃ§Ã£o

1. Hospedagem barata:
A empresa escolhe um servidor de baixo custo, que cai com frequÃªncia. A equipe gasta mais tempo (e dinheiro) corrigindo falhas e migraÃ§Ãµes.

2. Desenvolvedores juniores sem supervisÃ£o:
A contrataÃ§Ã£o Ã© mais barata no inÃ­cio, mas o cÃ³digo mal estruturado exige reescrita completa meses depois.

3. Uso de tecnologias defasadas:
Optar por ferramentas antigas para economizar licenÃ§as leva a altos custos de manutenÃ§Ã£o e falta de compatibilidade no futuro.

---

## - ğŸŒ IntangÃ­vel

- O **front-end** Ã© apenas a ponta do iceberg.  
- HÃ¡ custos de operaÃ§Ã£o e sustentaÃ§Ã£o de plataforma.  
- Um sistema envolve mÃºltiplos bancos de dados e linguagens.  
- O verdadeiro valor estÃ¡ na **integraÃ§Ã£o de sistemas** e na **engenharia de dados**.

---

## 4 Classe UML upado nas documentaÃ§Ãµes. ![Diagrama UML de relacionamento](https://github.com/ErickvFaria/bertoti/blob/main/UML_relacionamento.png)



ğŸ‘¨â€ğŸ“ Autor
Erick VinÃ­cius de Faria

Curso: Banco de Dados â€“ 2Âº semestre
