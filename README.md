# 💻 Engenharia de Software

Projeto desenvolvido para a disciplina de **Engenharia de Software**, ministrada pelo professor **Bertoti**.

---

## 🛠️ Ferramenta Utilizada
- **IntelliJ IDEA**
- **Ollama**
- **GitHub**



---

## 🎯 Objetivo

Este repositório tem como finalidade **armazenar e organizar os códigos e atividades** da disciplina, servindo como apoio para os estudos e o desenvolvimento prático dos conceitos aprendidos em sala de aula.

---

## 📖 Comentários sobre o livro *Software Engineering at Google* (O'Reilly)

### 🔹 1. Primeiro Trecho
O livro traz ensinamentos valiosos sobre as atribuições de cada profissional da área de tecnologia.  
Há diferenças claras entre cargos e responsabilidades:  
- O **engenheiro de software** lida com trabalhos mais complexos e de longo prazo.  
- O **cientista de dados** pode atuar como programador, criando soluções específicas.  

A principal distinção está na **capacidade lógica e visão de futuro** do engenheiro de software, que precisa pensar em soluções estruturadas e tomar decisões técnicas mais rigorosas.

---

### 🔹 2. Segundo Trecho
- Programar vai além de apenas escrever código.  
- É necessário pensar em **como o código vai evoluir ao longo do tempo**.  
- O desenvolvedor deve **acompanhar as mudanças da empresa**.  
- É importante **reduzir riscos e custos futuros**.  
- O código possui um **ciclo de vida**, da criação até a descontinuidade.  
- A engenharia de software envolve:
  - **Planejamento**  
  - **Manutenção**  
  - **Cuidado contínuo**

---
## 3 - ⚖️ Exemplos de Tradeoffs

# 🕐 1. Velocidade x Qualidade
1. Entrega apressada de um app mobile:
A equipe lança o aplicativo antes do prazo para atender uma campanha de marketing, mas vários bugs aparecem logo após o lançamento.

2. Sistema web sem testes automatizados:
Para economizar tempo, os desenvolvedores pulam os testes. O sistema funciona, mas falhas críticas surgem nas atualizações seguintes.

3. Site feito às pressas para um cliente:
O site é entregue no prazo, mas o código é desorganizado, dificultando futuras alterações e correções.

# ⚙️ 2. Simplicidade x Escalabilidade

1. Banco de dados único para tudo:
Um sistema pequeno usa apenas um banco centralizado (ex: SQLite), mas quando o número de usuários cresce, ele não aguenta a demanda.

2. Código “hardcoded”:
Valores fixos são colocados diretamente no código (como URLs ou taxas). Isso simplifica o início, mas dificulta ajustes quando o sistema precisa se adaptar.

3. Arquitetura monolítica:
Criar tudo em um único projeto é mais simples no começo, mas torna o sistema difícil de escalar ou dividir em microsserviços no futuro.

# 💰 3. Custo x Manutenção

1. Hospedagem barata:
A empresa escolhe um servidor de baixo custo, que cai com frequência. A equipe gasta mais tempo (e dinheiro) corrigindo falhas e migrações.

2. Desenvolvedores juniores sem supervisão:
A contratação é mais barata no início, mas o código mal estruturado exige reescrita completa meses depois.

3. Uso de tecnologias defasadas:
Optar por ferramentas antigas para economizar licenças leva a altos custos de manutenção e falta de compatibilidade no futuro.


## 🌐 Conceitos Intangíveis

- O **front-end** é apenas a ponta do iceberg.  
- Há custos de operação e sustentação da plataforma.  
- Um sistema envolve **múltiplos bancos de dados e linguagens**.  
- O verdadeiro valor está na **integração de sistemas** e na **engenharia de dados**.

---

## 🧩 Diagrama UML de Relacionamento

### 📄 Descrição
O diagrama a seguir representa a relação entre as classes **Fazenda**, **Humano** e **Ovelha**, conforme desenvolvido na atividade prática da disciplina.

<p align="center">
  <img src="https://github.com/ErickvFaria/bertoti/blob/main/UML_relacionamento.png?raw=true" alt="Diagrama UML de Relacionamento" width="600"/>
</p>

---

## 👨‍🎓 Autor

**Erick Vinícius de Faria**  
Curso: **Banco de Dados – 2º Semestre**  
FATEC São José dos Campos
